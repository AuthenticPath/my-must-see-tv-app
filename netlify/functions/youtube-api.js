// netlify/functions/youtube-api.js
// This function will talk to the YouTube API to search for videos and update playlists.
// It will require the user's access_token to act on their behalf for playlist modifications.

// IMPORTANT: Set your YouTube Data API Key in Netlify environment variables
const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY; // Your regular YouTube Data API Key

// We expect node-fetch@2 to be installed, which uses require()
const fetch = require('node-fetch');

// Helper function to make authenticated calls to the YouTube API using a user's access token
async function callYouTubeApiWithUserAuth(endpoint, accessToken, method = 'GET', body = null) {
    const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';
    const headers = {
        'Authorization': `Bearer ${accessToken}`, // User's access token for actions on their behalf
        'Accept': 'application/json',
    };
    if (method === 'POST' || method === 'PUT') {
        headers['Content-Type'] = 'application/json';
    }

    const options = { method, headers };
    if (body) {
        options.body = JSON.stringify(body);
    }

    const response = await fetch(`${YOUTUBE_API_BASE}${endpoint}`, options);
    if (!response.ok) {
        const errorData = await response.json();
        console.error("[User Auth] YouTube API Error:", errorData.error.message, "Status:", response.status, "Details:", errorData);
        throw new Error(`[User Auth] YouTube API request failed: ${errorData.error.message} (Status: ${response.status})`);
    }
    return response.json();
}

// --- NEW: Helper function to parse ISO 8601 duration to seconds ---
// This function takes YouTube's duration format (like "PT10M32S") and converts it to total seconds.
function parseISO8601Duration(isoDuration) {
    if (!isoDuration) return 0;
    // Regex to capture hours (H), minutes (M), and seconds (S) from the ISO string
    const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
    const matches = isoDuration.match(regex);
    if (!matches) return 0; // Return 0 if the format doesn't match

    const hours = parseInt(matches[1] || 0);   // Get hours, or 0 if not present
    const minutes = parseInt(matches[2] || 0); // Get minutes, or 0 if not present
    const seconds = parseInt(matches[3] || 0); // Get seconds, or 0 if not present

    return (hours * 3600) + (minutes * 60) + seconds; // Convert all to seconds and sum up
}


// Main handler function for this serverless endpoint
exports.handler = async (event, context) => {
    if (!YOUTUBE_API_KEY) {
        console.error("[youtube-api] Server configuration error: Missing YouTube API Key.");
        return {
            statusCode: 500,
            body: JSON.stringify({ error: "Server configuration error: Missing YouTube API Key." })
        };
    }

    const authHeader = event.headers.authorization;
    let accessToken = null;

    if (authHeader && authHeader.startsWith('Bearer ')) {
        accessToken = authHeader.split(' ')[1];
    }

    const { action, payload } = JSON.parse(event.body);
    // --- MODIFIED: Updated console log for payload to be more robust ---
    console.log(`[youtube-api] Action: ${action}, Payload:`, payload ? JSON.stringify(payload, null, 2) : 'No payload');


    try {
        if (action === 'findOrCreatePlaylist') {
            if (!accessToken) return { statusCode: 401, body: JSON.stringify({ error: "Missing access token for findOrCreatePlaylist." }) };
            const { playlistName } = payload;
            console.log(`[youtube-api] Finding/creating playlist: ${playlistName}`);

            let playlistsData = await callYouTubeApiWithUserAuth(`/playlists?part=snippet&mine=true&maxResults=50`, accessToken);
            let existingPlaylist = playlistsData.items.find(p => p.snippet.title === playlistName);

            if (existingPlaylist) {
                console.log(`[youtube-api] Playlist "${playlistName}" found with ID: ${existingPlaylist.id}`);
                return { statusCode: 200, body: JSON.stringify({ playlistId: existingPlaylist.id }) };
            } else {
                console.log(`[youtube-api] Playlist "${playlistName}" not found. Creating new one...`);
                const newPlaylistData = await callYouTubeApiWithUserAuth(`/playlists?part=snippet,status`, accessToken, 'POST', {
                    snippet: { title: playlistName, description: "My daily dose of must-see TV generated by my app!" },
                    status: { privacyStatus: "private" }
                });
                console.log(`[youtube-api] Playlist "${playlistName}" created with ID: ${newPlaylistData.id}`);
                return { statusCode: 200, body: JSON.stringify({ playlistId: newPlaylistData.id }) };
            }
        }
        // --- Action: Fetch recent videos from a specific channel, filtered by keywords, duration, and negative keywords ---
        else if (action === 'fetchChannelVideos') {
            // --- MODIFIED: Destructure new filter parameters ---
            const {
                channelId,
                keywords, // Positive keywords
                publishedAfter,
                minDuration,      // Minimum duration in minutes
                maxDuration,      // Maximum duration in minutes
                negativeKeywords  // Keywords to exclude videos
            } = payload;

            // --- MODIFIED: Updated log message to include new filters ---
            console.log(`[youtube-api] Fetching videos for channel: ${channelId}, Keywords: ${keywords || 'None'}, MinDur: ${minDuration || 'N/A'}, MaxDur: ${maxDuration || 'N/A'}, Negative: ${negativeKeywords || 'None'}, After: ${publishedAfter || 'Any'}`);

            // Step 1: Search for videos from the channel using the API Key
            let searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&order=date&type=video&maxResults=20&key=${YOUTUBE_API_KEY}`;
            if (publishedAfter) {
                 searchUrl += `&publishedAfter=${publishedAfter}`;
            }

            const searchResponse = await fetch(searchUrl);
            if (!searchResponse.ok) {
                const errorData = await searchResponse.json();
                console.error("[youtube-api] YouTube Search API error:", errorData);
                throw new Error(`YouTube Search API error (search): ${errorData.error.message}`);
            }
            const videoDataFromSearch = await searchResponse.json();
            console.log(`[youtube-api] Found ${videoDataFromSearch.items.length} raw videos from search for channel ${channelId}.`);

            if (videoDataFromSearch.items.length === 0) {
                console.log(`[youtube-api] No initial videos found from search for channel ${channelId}.`);
                return { statusCode: 200, body: JSON.stringify({ videos: [] }) };
            }

            // --- NEW: Step 2: Get video IDs from search results and fetch their full details (including duration) ---
            const videoIdsFromSearch = videoDataFromSearch.items.map(item => item.id.videoId).join(',');

            // Call the /videos endpoint to get contentDetails (for duration) and full snippet
            // This uses the API KEY because it's public data details
            const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoIdsFromSearch}&key=${YOUTUBE_API_KEY}`;
            const detailsResponse = await fetch(detailsUrl);
            if (!detailsResponse.ok) {
                const errorData = await detailsResponse.json();
                console.error("[youtube-api] YouTube Videos API error (fetching details):", errorData);
                throw new Error(`YouTube Videos API error (details): ${errorData.error.message}`);
            }
            const detailedVideoData = await detailsResponse.json();
            console.log(`[youtube-api] Fetched details for ${detailedVideoData.items.length} videos for channel ${channelId}.`);

            // Map to a cleaner structure, including duration and full description
            let videos = detailedVideoData.items.map(item => ({
                id: item.id, // For /videos endpoint, id is directly item.id
                title: item.snippet.title,
                description: item.snippet.description, // Full description
                publishedAt: item.snippet.publishedAt,
                thumbnail: item.snippet.thumbnails.default.url,
                duration: item.contentDetails.duration // ISO 8601 duration format (e.g., "PT10M32S")
            }));

            // --- NEW: Step 3: Apply all filters ---

            // 3a. Filter by positive keywords (in title OR description)
            if (keywords && keywords.trim() !== "") {
                const keywordArray = keywords.toLowerCase().split(',').map(k => k.trim()).filter(k => k);
                videos = videos.filter(video =>
                    keywordArray.some(keyword => (
                        (video.title && video.title.toLowerCase().includes(keyword)) ||
                        (video.description && video.description.toLowerCase().includes(keyword))
                    ))
                );
                console.log(`[youtube-api] Filtered to ${videos.length} videos after positive keywords.`);
            }

            // 3b. Filter by negative keywords (NOT in title OR description)
            if (negativeKeywords && negativeKeywords.trim() !== "") {
                const negativeKeywordArray = negativeKeywords.toLowerCase().split(',').map(k => k.trim()).filter(k => k);
                videos = videos.filter(video =>
                    !negativeKeywordArray.some(negKeyword => ( // Note the "!" for NOT some
                        (video.title && video.title.toLowerCase().includes(negKeyword)) ||
                        (video.description && video.description.toLowerCase().includes(negKeyword))
                    ))
                );
                console.log(`[youtube-api] Filtered to ${videos.length} videos after negative keywords.`);
            }

            // 3c. Filter by duration
            // Only apply duration filter if minDuration or maxDuration is provided
            if (minDuration !== null || maxDuration !== null) {
                videos = videos.filter(video => {
                    const durationInSeconds = parseISO8601Duration(video.duration);
                    const durationInMinutes = durationInSeconds / 60;

                    let passesMinDuration = true;
                    if (minDuration !== null && durationInMinutes < minDuration) {
                        passesMinDuration = false;
                    }

                    let passesMaxDuration = true;
                    if (maxDuration !== null && durationInMinutes > maxDuration) {
                        passesMaxDuration = false;
                    }
                    // For detailed logging of duration filtering decisions:
                    // console.log(`Video: "${video.title}", Duration: ${durationInMinutes.toFixed(2)}m (Raw: ${video.duration}), Min: ${minDuration}, Max: ${maxDuration}, PassesMin: ${passesMinDuration}, PassesMax: ${passesMaxDuration}, FinalPass: ${passesMinDuration && passesMaxDuration}`);
                    return passesMinDuration && passesMaxDuration;
                });
                console.log(`[youtube-api] Filtered to ${videos.length} videos after duration check.`);
            }


            console.log(`[youtube-api] Final filtered videos for channel ${channelId}: ${videos.length}`);
            return { statusCode: 200, body: JSON.stringify({ videos }) };
        }
        else if (action === 'addVideoToPlaylist') {
            if (!accessToken) return { statusCode: 401, body: JSON.stringify({ error: "Missing access token for addVideoToPlaylist." }) };
            const { playlistId, videoId } = payload;
            console.log(`[youtube-api] Adding video ID ${videoId} to playlist ID ${playlistId}`);

            const result = await callYouTubeApiWithUserAuth(`/playlistItems?part=snippet`, accessToken, 'POST', {
                snippet: {
                    playlistId: playlistId,
                    position: 0,
                    resourceId: {
                        kind: "youtube#video",
                        videoId: videoId
                    }
                }
            });
            console.log(`[youtube-api] Successfully added video ID ${videoId} to playlist.`);
            return { statusCode: 200, body: JSON.stringify({ success: true, videoIdAdded: videoId, item: result }) };
        }
        else if (action === 'getPlaylistItems') {
            if (!accessToken) return { statusCode: 401, body: JSON.stringify({ error: "Missing access token for getPlaylistItems." }) };
            const { playlistId } = payload;
            console.log(`[youtube-api] Getting items for playlist ID ${playlistId}`);
            let allItems = [];
            let nextPageToken = null;
            do {
                const playlistItemsData = await callYouTubeApiWithUserAuth(`/playlistItems?part=snippet&playlistId=${playlistId}&maxResults=50${nextPageToken ? '&pageToken='+nextPageToken : ''}`, accessToken);
                allItems = allItems.concat(playlistItemsData.items.map(item => item.snippet.resourceId.videoId));
                nextPageToken = playlistItemsData.nextPageToken;
            } while (nextPageToken);
            console.log(`[youtube-api] Found ${allItems.length} video IDs in playlist ${playlistId}.`);
            return { statusCode: 200, body: JSON.stringify({ videoIds: allItems }) };
        }
        else {
            console.warn(`[youtube-api] Invalid action received: ${action}`);
            return { statusCode: 400, body: JSON.stringify({ error: "Invalid action." }) };
        }

    } catch (error) {
        console.error("[youtube-api] Error in handler function:", error.message, error.stack);
        return {
            statusCode: 500,
            body: JSON.stringify({ error: error.message || "An internal server error occurred in youtube-api." })
        };
    }
};